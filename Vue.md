# Vue

# `05.06`

## Front Framework가 나온 이유

- Vue.js, React, Angular 등

- 과정의 불편함

  - 데이터가 변하고 그 데이터에 연동된 엘리먼트를 가져오고 엘리먼트의 내부를 바꿔주는 과정을 반복하는 것이 불편함

  → 데이터가 변하면 나머지를 해주는 프레임워크 등장

<br>

# `vue 문법 정리 필요!` 

<br>

<br>

# 05.07

## 알고리즘 왜 적용시켜야할까

- 어떤 목적을 달성하기 위해 도출하기 위한 과정(유의미한 결과를 만들어내는 과정)
- 효율적인 코드를 작성(속도 개선)

<br>

<br>

# `05.10`

# SFC(Single File Component)

- 하나의 파일로 구성하면 변수 관리와 코드의 유지 보수가 어렵다.

- → 각 기능별로 나눠서 개발하면 처음에 준비할 때는 어렵지만 사이트가 커질수록 변수 관리와 유지 보수가 좋다, 한 화면 안에서 여러가지 컴포넌트가 존재

- 컴포넌트로 개발한다는 것은 하나의 파일을 의미하는 것은 아니라 하나의 파일 안에 여러가지 컴포넌트가 들어갈 수 있다는 것을 말한다.

- Vue는 SFC 개발을 사용한다.(.vue 파일 하나가 하나의 컴포넌트 역할)

<br>

## Component(컴포넌트)

- 특정 기능을 하는 코드 블럭을 만들어 놓으면 다른 곳에서도 재사용 할 수 있다.

  ex) const app

<br>

## Node.js

- 단순히 브라우저에서만 작동할 수 있었던 JS를 밖에서도 사용할 수 있게 만들어준다.(여러 OS 환경에서 가능하게)

- 설치 참고 : https://cli.vuejs.org/guide/installation.html

  ```python
  # 참고
  
  vue 파일을 만들때는 git bash가 아니라 vscode로 진행
  git bash로 하면 선택할때 화살표를 움직일 수가 없음 → 인터렉티브 터미널이 아니기 때문에
  처음에 vue create를 한 후, 서버를 키려면 이동해야한다. cd로 이동한 후 작업 시작 !
  ```

<br>

## Module

- 단지 파일 하나를 의미

  ex) 스크립트 하나 === 모듈 하나

- 의존성 문제 → 처음에 등장했던 이유는 JS, app이 커져서 등장했는데 모듈의 수가 점점 많아짐, 의존성이 깊어짐(ex. 4.2버전에서만 동작) → 문제가 발생하면 어떤 모듈 간의 문제인지 파악하기 어려워짐 ⇒ Webpack 등장 : 모듈간의 의존성을 해결하기 위해

<br>

## Webpack

static module bundler

<br>

## Bundler

- 모듈 의존성 문제를 해결해주는 작업이 Bundling, 이러한 일을 해주는 도구가 Bundler
- 순서에 영향을 받지 않게 묶어줌

<br>

## Babel

- JS는 표준화의 영향으로 작성된 코드의 스펙트럼이 매우 다양하다.

- 같은 의미의 코드인데 문법이 안맞아서 다시 작성해야하는 일이 있음 → 이러한 문제를 해결하기 위해 사용한다.

- 원시코드(최신 버전)를 목적 코드(구 버전)으로 옮기는 번역기

  ex) ES2015 → ES5로 compile

- 구버전을 사용하는 애플리케이션을 대응

- 기본적으로 babel 설정이 되어있음

<br>

# Vue cli

개발을 하다보니 하나의 파일에서 모든 코드를 작성하는 것이 너무 어렵다.

→ 파일을 분리해서 작성

→ 많으면 수백, 수천개의 파일이 만들어짐 → a.js, b.js ... z.js ... 전부를 받아와야 응답하는 index.js를 보여줄 수 있음 → 개발은 나눠서 하는 게 좋고 속도는 하나의 파일이 좋다 !

⇒ 하나로 묶어서 만들어주는 것 webpack(bundler), 변수이름도 안겹치게 해줌 → 설정이 어렵다 → vue-cli를 만듦(ex. 장고의 django-admin startproject) : vue의 개발환경을 세팅해준다

⇒ 개발환경을 세팅해주고 하나로 묶어서 서빙해준다.

- http는 연결횟수가 작을수록 좋다(같은 용량이라도 하나의 파일이면 빠름)

- 요청에 따라 내 컴퓨터에 담긴 파일을 전송해주는 서버를 만들고 + workshop.html을 태우는게  유리하다. (기존의 workshop.html의 주소는 파일의 주소임)

- vue-cli 안에 있는 개발용 웹서버가 localhost 8080을 만들어줌

<br>

## Vue cli 구성

### babel.config.js

> - 바벨 설정과 관련된 것들

### node_modules

> - Webpack이 들어가있음

### public

> - favicon은 우리가 아는 favicon
> - index.html : 뼈대가 되는 html - runserve때 켜지는 것

### src

> - assets : Webpack에 빌드되는 정적인 파일들
> - components : 하위 컴포넌트 파일들이 들어감
> - App.vue : 뷰에서 최상위 컴포넌트
> - 주로 작업하는 공간

### main.js

> - Webpack이 빌드를 시작할 때 가장 먼저 불러오는 시작점(entry point)
> - 뷰의 전역에서 사용할 수 있는 모듈을 등록할 수 있음

### package.json

> - dependencies : 개발환경과 프로젝트 레벨에서까지 사용
> - devDependencie : 개발환경에서 사용하는 모듈(requirements.txt와 비슷)

### package-lock.json

> - 동일한 종속성을 유지하기 위해 도와줌, 배포, 개발할 때
> - 개발 과정 중에 의존성 충돌 방지
> - 모든 의존성을 가지는 패키지를 명시 (`$npm ls`)

### .gitignore

> - gitignore

<br>

## 참고

- npm으로 설치하면 자동으로 package에서 알아서 수정해줌, (삭제도) → 따로 관여 x

- 만들면 자동으로 git init이 선언됨(master가 붙어있음)

- .vue 하나가 component 하나 !

#### `<script scope>`, `<script>` 차이점

> - scope를 적용 안하면 하위 컴포넌트까지 적용
> - 적용 되어있으면 그 컴포넌트만 적용 !

<br>

## 웹서버 / 웹애플리케이션서버

- 웹서버 기본 역할 중 하나 : 내 컴퓨터에 있는 파일을 요청자에게 응답으로 전송해주는 것

- 웹애플리케이션서버 : 웹서버에 장착할 수 있는 확장팩 느낌, ex) django

- 웹애플리케이션서버 하는 일 : db관리, url, body(뭐가 적혀있는지), method, 쿠키 인증여부 등에 따라서 동작하고 그에 맞는 응답을 만들어서 주는 프로그램

→ 사용자의 응답으로 index.html, index.js, style.css만 주면 된다면 웹서버 하나만 있어도 됨

<br>

## Vue Router

- `Vue Router` 참고 사이트 : https://router.vuejs.org/kr/guide/

- url이 갈 수 있는 경로들을 결정

- `vue add router` : router는 CLI를 사용할 경우에는 프로젝트마다 추가해주는 것

- SPA의 장점 → url이 변경되지 않는다 !

- 사용자 경험을 위해 `History API`를 이용해서 router를 구현
- 브라우저의 히스토리는 남기지만 실제 페이지는 이동하지 않는 기능을 지원
- 이것을 통해 뒤로 가기, 앞으로 가기가 가능

- `History` 참고 사이트 : https://developer.mozilla.org/ko/docs/Web/API/History

- 페이지를 이동하는 경험을 주지만 사실은 새로운 컴포넌트를 주는 것

- `url이 움직일 수 없다는 단점을 해결하기 위해 등장`

- 멈춰있는 듯한 경험을 움직이게 보여줌 → url에 바뀌지 않으면 사용자가 멈춰있다라는 느낌을 들게 함, 이를 해결하기 위해 다른 컴포넌트를 볼 때 페이지가 이동했다는 느낌을 주게 함

- 페이지를 렌더링하는거랑 컴포넌트를 렌더링 하는거랑 큰 차이 → 서버로 요청을 보내는 것 여부(페이지 렌더링 : 서버로 요청)

