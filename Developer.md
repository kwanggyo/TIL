# `07.27`

# 개발자의 나쁜 습관

## 코드 관리

### 가독성

20줄을 2 ~ 3줄로 줄이는 것은 좋지만 가독성을 생각하면서 !

코드의 접근성을 먼저 생각하고 똑똑한 코드는 그 다음에 생각

### 바이트를 줄이자

웹 사이트 크기를 수 바이트 줄이는 게 그렇게 중요한지?

더 중요한 요구사항들이 있지 않은지

최적화는 프로젝트의 가장 마지막에

요구사항이 바뀌면 그 앞에 해왔던 최적화들은 쓰레기가 된다.

### 코딩 스타일

코딩 스타일을 지키지 않으면 진행하기 어려운 프로젝트가 된다.

작은 부분이라도 스타일은 꼭 지키자

### 작은 오류 로그는 무시

예외를 무시하든 에러를 보고하지 않는 라이브러리를 쓰든 오류 가능성을 숨기는 방법은 여러 가지가 있다. 하지만 이 중 하나라도 주요 이슈가 터지면 그걸 고치는데 몇 배의 시간이 걸린다.

### 변수명

이름만 잘 지어도 코드를 알아보는데 걸리는 시간을 1시간에서 10초로 줄일 수 있다.

### 개발자 툴과 IDE 사용법 미숙

핫키, 단축키, 환경 세팅은 생각보다 더 중요

이것을 익힘으로써 코딩의 context를 바꾸는 게 중요함

익숙해져야 비로소 코드 그 자체에 집중할 수 있게 된다.

개발 스타일에 따라 잘 맞는 IDE가 있다.

Vscode, Subime text, Eclipse, Intellij 등

### 눈 감고 소스 코드 복붙

코드 재사용 전에는 꼭 한번은 꼼꼼히 읽어 볼 것

안 읽고 복붙 했다가 장애 발생시 조치시간은 길어짐

나중에라도 꼭 읽어보기

### 라이브러리

예제 몇 개 봤다고 새 라이브러리를 마스터할 수는 없다.

직접 써보고 분석하면서 익히는 것들이 분명히 있다.

<br>

## 팀워크

### 계획을 자주 바꾸기

프로젝트를 망하게 만드는 가장 쉬운 방법

무분별한 계획 변경은 일정지연 및  개발기간 부족으로 이어짐

### 계획 고집

계획을 바꾸는 것도 나쁘지만, 실현 불가능한 계획을 고집하는 것도 나쁘다.

항상 아이디어를 팀과 공유하고 피드백을 받고 막혔을 땐 조언을 받자

### 혼자 일하기

프로젝트 진행현황, 아이디어 등은 팀과 항상 공유해야 한다.

팀원들과의 지속적인 대화는 본인뿐만 아니라 팀원들에게도 도움이 된다.

### 나쁜 코드 짜기를 거부한다.

나쁜 코드 : 프로젝트 마감 일에 쫓겨 작동만 가능하도록 급조하여 만든 엉망인 코드

나쁜 코드라도 빠르게 짤 수 있는 능력도 필요함(실제로 많이 일어나는 일)

꼭 짜라는 것이 아니라 상황에 따라 짤 수도 있어야 한다.

### 본인의 실수를 인정하지 않는 것

전문가는 자기 분야에 거만해지기 마련

자만심, 자존심에 눌려 쌓아온 신뢰를 깎아 먹는 게 두려워 자신의 실수를 인정하지 않는 것이 진짜 실수

### 내가 배운 것을 공유하지 않는 것

개발자로서의 가치는 코드로만 보여지는 게 아님

코드를 짜면서 당신이 무얼 배웠는지, 경험을 공유하고, 왜 그렇게 짰는지를 설명하는 과정들이 본인을 스킬업 시킨다.

### 늦은 피드백

팀원 모두가 동일한 정보를 공유하고 있는 상태(on the same page)로 만들어야 한다.

팀워크의 기본

### 내 코드에 집착하기

나의 코드에 딴지를 거는거지 나한테 딴지를 거는 건 아니다.

왜 그렇게 짰는지 잘 설명하고, 더 나은 방법이 있다면 받아들이는 게 이득

<br>

## 테스트 및 유지보수

### 통과할 정도의 테스트만 만들기

통과하지 못할 테스트도 만들어야 한다.

그래야 프로젝트가 진행되고 이슈 tracking이 가능해진다.

### 기능 구현 이외의 사항을 무시

기능 구현에만 몰두하다 보면 성능, 보안 등의 문제를 소홀히 하기 쉽다.

이외의 사항은 checklist에 적어두고 관리

⇒ 좋은 방법이 좋은 습관이 되면 매 상황마다 좋은 방법을 찾을 필요가 없다.

<br>

<br>

# `07.28`

# 관심사 분리

어떤 로직을 해야하는지 메소드를 정의하고 위에서 아래로 정의해나감

## 코드 레벨의 관심사 분리

다른 함수에서 어떤 일을 하는지 관심이 있는가

각 함수에서 수정이 필요할 때 다른 함수에 영향을 미치는가

내가 알아야 하는 건 오직 내가 호출하는 녀석뿐

표현 계층의 코드는 Human Readable 해야한다.

### 위의 관심사 분리를 반영한 스프링의 계층 분리

- 주니어 개발자도 쉽게 기능 개발을 위해서 투입될 수 있다.
- 코드를 이상하게 짰다고 해서 다른 계층과 기능으로 전파되지 않는다.
- 문제가 생겨도 문제가 생긴 지점을 찾기 쉽다.
- 엔터프라이즈 코드(스프링 내부가 어떻게 작동하는지)가 어떻게 동작하는지는 개별 개발자의 관심사가 아니다.
- 대규모 프로젝트 개발에 유리하다.

Servlet filter 2

Controller 1

Service 3

Repository 4

- 숫자는 호출 순서

<br>

## 개발자 간의 관심사도 분리할 수 있다.

프론트/백엔드 엔드가 아직 안나와서 테스트를 못하는데요(교착 상태)

API를 정의하는 이유가 무엇일까?

관심사가 제대로 분리되고 API를 정의했다면 발생 안함

→ API를 정의한 뒤에 제대로 동작하지 않는 것은 각 개발자의 책임

→ API를 만들 때까지 치열한 논의와 토론은 중요하다.

### 스웨거를 많이 사용한다.

- API 개발 도구로 인터페이스를 정의하고 인터페이스에 맞게 개발을 하기 위해서 사용하는 도구

<br>

## 블랙박스식 개발

Input → Some Module → Output

모듈이 어떻게 구현되었는지를 보지 않고 Input과 Output에 대해서만 관심을 두는 것을 블랙박스식 개발이라고 한다.

관심사 분리를 하기 위해서는 블랙박스식 개발이 필수

오직 관심을 가져야 할 것은  Input과 Output을 정의하고 그것이 정상적으로 동작하느냐이다.

### 블랙박스식 개발의 장점

리팩토링에 유리하다(테스트 코드는 여기에 사용한다)

병목 지점을 찾아내는 것이 쉽다.

기능의 분리가 쉽다.

성능 개선 시 개선 부분을 찾는 것이 쉽다.(ex. 걸리는 시간을 각각 측정)

### 리펙토링 코드 테스트

Input에 대해서 Output이 잘 나왔으면 성공

### 동시 접속자가 많은 사이트

MSA구조로 설계

앞쪽 노드밸런서를 놓고 게이트웨이를 통해 API서버를 연결, DB로 부터 쿼리를 받아오는 방식

<br>

## 관심사 분리를 하면?

장애가 발생해도 그것이 전파되지 않는다.

새로운 관심사를 추가하는 것이 쉽다.

관심사마다 한정된 자원을 할당할 수 있다.

MSA(Micro Service Architecture)의 근간이 된다.