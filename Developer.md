# `07.27`

# 개발자의 나쁜 습관

## 코드 관리

### 가독성

20줄을 2 ~ 3줄로 줄이는 것은 좋지만 가독성을 생각하면서 !

코드의 접근성을 먼저 생각하고 똑똑한 코드는 그 다음에 생각

### 바이트를 줄이자

웹 사이트 크기를 수 바이트 줄이는 게 그렇게 중요한지?

더 중요한 요구사항들이 있지 않은지

최적화는 프로젝트의 가장 마지막에

요구사항이 바뀌면 그 앞에 해왔던 최적화들은 쓰레기가 된다.

### 코딩 스타일

코딩 스타일을 지키지 않으면 진행하기 어려운 프로젝트가 된다.

작은 부분이라도 스타일은 꼭 지키자

### 작은 오류 로그는 무시

예외를 무시하든 에러를 보고하지 않는 라이브러리를 쓰든 오류 가능성을 숨기는 방법은 여러 가지가 있다. 하지만 이 중 하나라도 주요 이슈가 터지면 그걸 고치는데 몇 배의 시간이 걸린다.

### 변수명

이름만 잘 지어도 코드를 알아보는데 걸리는 시간을 1시간에서 10초로 줄일 수 있다.

### 개발자 툴과 IDE 사용법 미숙

핫키, 단축키, 환경 세팅은 생각보다 더 중요

이것을 익힘으로써 코딩의 context를 바꾸는 게 중요함

익숙해져야 비로소 코드 그 자체에 집중할 수 있게 된다.

개발 스타일에 따라 잘 맞는 IDE가 있다.

Vscode, Subime text, Eclipse, Intellij 등

### 눈 감고 소스 코드 복붙

코드 재사용 전에는 꼭 한번은 꼼꼼히 읽어 볼 것

안 읽고 복붙 했다가 장애 발생시 조치시간은 길어짐

나중에라도 꼭 읽어보기

### 라이브러리

예제 몇 개 봤다고 새 라이브러리를 마스터할 수는 없다.

직접 써보고 분석하면서 익히는 것들이 분명히 있다.

<br>

## 팀워크

### 계획을 자주 바꾸기

프로젝트를 망하게 만드는 가장 쉬운 방법

무분별한 계획 변경은 일정지연 및  개발기간 부족으로 이어짐

### 계획 고집

계획을 바꾸는 것도 나쁘지만, 실현 불가능한 계획을 고집하는 것도 나쁘다.

항상 아이디어를 팀과 공유하고 피드백을 받고 막혔을 땐 조언을 받자

### 혼자 일하기

프로젝트 진행현황, 아이디어 등은 팀과 항상 공유해야 한다.

팀원들과의 지속적인 대화는 본인뿐만 아니라 팀원들에게도 도움이 된다.

### 나쁜 코드 짜기를 거부한다.

나쁜 코드 : 프로젝트 마감 일에 쫓겨 작동만 가능하도록 급조하여 만든 엉망인 코드

나쁜 코드라도 빠르게 짤 수 있는 능력도 필요함(실제로 많이 일어나는 일)

꼭 짜라는 것이 아니라 상황에 따라 짤 수도 있어야 한다.

### 본인의 실수를 인정하지 않는 것

전문가는 자기 분야에 거만해지기 마련

자만심, 자존심에 눌려 쌓아온 신뢰를 깎아 먹는 게 두려워 자신의 실수를 인정하지 않는 것이 진짜 실수

### 내가 배운 것을 공유하지 않는 것

개발자로서의 가치는 코드로만 보여지는 게 아님

코드를 짜면서 당신이 무얼 배웠는지, 경험을 공유하고, 왜 그렇게 짰는지를 설명하는 과정들이 본인을 스킬업 시킨다.

### 늦은 피드백

팀원 모두가 동일한 정보를 공유하고 있는 상태(on the same page)로 만들어야 한다.

팀워크의 기본

### 내 코드에 집착하기

나의 코드에 딴지를 거는거지 나한테 딴지를 거는 건 아니다.

왜 그렇게 짰는지 잘 설명하고, 더 나은 방법이 있다면 받아들이는 게 이득

<br>

## 테스트 및 유지보수

### 통과할 정도의 테스트만 만들기

통과하지 못할 테스트도 만들어야 한다.

그래야 프로젝트가 진행되고 이슈 tracking이 가능해진다.

### 기능 구현 이외의 사항을 무시

기능 구현에만 몰두하다 보면 성능, 보안 등의 문제를 소홀히 하기 쉽다.

이외의 사항은 checklist에 적어두고 관리

⇒ 좋은 방법이 좋은 습관이 되면 매 상황마다 좋은 방법을 찾을 필요가 없다.

<br>

<br>

# `07.28`

# 관심사 분리

어떤 로직을 해야하는지 메소드를 정의하고 위에서 아래로 정의해나감

## 코드 레벨의 관심사 분리

다른 함수에서 어떤 일을 하는지 관심이 있는가

각 함수에서 수정이 필요할 때 다른 함수에 영향을 미치는가

내가 알아야 하는 건 오직 내가 호출하는 녀석뿐

표현 계층의 코드는 Human Readable 해야한다.

### 위의 관심사 분리를 반영한 스프링의 계층 분리

- 주니어 개발자도 쉽게 기능 개발을 위해서 투입될 수 있다.
- 코드를 이상하게 짰다고 해서 다른 계층과 기능으로 전파되지 않는다.
- 문제가 생겨도 문제가 생긴 지점을 찾기 쉽다.
- 엔터프라이즈 코드(스프링 내부가 어떻게 작동하는지)가 어떻게 동작하는지는 개별 개발자의 관심사가 아니다.
- 대규모 프로젝트 개발에 유리하다.

Servlet filter 2

Controller 1

Service 3

Repository 4

- 숫자는 호출 순서

<br>

## 개발자 간의 관심사도 분리할 수 있다.

프론트/백엔드 엔드가 아직 안나와서 테스트를 못하는데요(교착 상태)

API를 정의하는 이유가 무엇일까?

관심사가 제대로 분리되고 API를 정의했다면 발생 안함

→ API를 정의한 뒤에 제대로 동작하지 않는 것은 각 개발자의 책임

→ API를 만들 때까지 치열한 논의와 토론은 중요하다.

### 스웨거를 많이 사용한다.

- API 개발 도구로 인터페이스를 정의하고 인터페이스에 맞게 개발을 하기 위해서 사용하는 도구

<br>

## 블랙박스식 개발

Input → Some Module → Output

모듈이 어떻게 구현되었는지를 보지 않고 Input과 Output에 대해서만 관심을 두는 것을 블랙박스식 개발이라고 한다.

관심사 분리를 하기 위해서는 블랙박스식 개발이 필수

오직 관심을 가져야 할 것은  Input과 Output을 정의하고 그것이 정상적으로 동작하느냐이다.

### 블랙박스식 개발의 장점

리팩토링에 유리하다(테스트 코드는 여기에 사용한다)

병목 지점을 찾아내는 것이 쉽다.

기능의 분리가 쉽다.

성능 개선 시 개선 부분을 찾는 것이 쉽다.(ex. 걸리는 시간을 각각 측정)

### 리펙토링 코드 테스트

Input에 대해서 Output이 잘 나왔으면 성공

### 동시 접속자가 많은 사이트

MSA구조로 설계

앞쪽 노드밸런서를 놓고 게이트웨이를 통해 API서버를 연결, DB로 부터 쿼리를 받아오는 방식

<br>

## 관심사 분리를 하면?

장애가 발생해도 그것이 전파되지 않는다.

새로운 관심사를 추가하는 것이 쉽다.

관심사마다 한정된 자원을 할당할 수 있다.

MSA(Micro Service Architecture)의 근간이 된다.

<br>

<br>

# `07.29`

# 데이터 크롤링

## 인터넷에서 데이터를 수집하는 방법

1. OpenAPI 등 공개된 API를 사용
   - 공공데이터 포털
   - NaverDevelopers
2. HTTP GET Method
   - 정보가 게시되어 있는 대상 웹사이트를  HTTP Get을 사용하여 html 코드를 얻고 Text Parsing해서 사용
   - Java / Go / Python 등 대부분에서 사용
3. Selenium Web Driver
   - 사람이 하는 것과 유사한 자동화 방법
   - 웹브라우저 인스턴스를 생성해 실행 시킨 후 해당 인스턴스를 컨트롤
     - 커맨드를 날려서 브라우저를 컨트롤
   - 웹사이트 테스트 자동화 목적으로 개발
   - 많이 사용하는 방법
   - 가상의 브라우저를 실행시키는 Haedless Mode(실제로 브라우저를 띄우지 않고 가상으로  띄움) 등이 있음 → 이것보다는 실제로 띄워서 하는 것이 빠름
4. 사람이 수작업으로 데이터를 수집하는 방법

## 웹 크롤러 vs 웹 스크래퍼

- 여러 사이트를 돌아다니면서 필요한 데이터를 가지고 오는 것 vs 고정된 형상에서 데이터를 가져옴
- 크롤러보다는 대부분 단순 스크래퍼 개발 수요가 많음
- 우리나라에서는 많은 기업들이 같은 의미로 혼용

### 웹 크롤러(Web Crawler)

- 조직적, 자동화 된 방법으로 웹을 탐색/수집 하는 프로그램

  ex) 구글, 네이버 등의 검색엔진 결과 데이터를 수집하기 위한 봇(Bot)

- API 호출로 데이터를 받는 것은 크롤링이 아님

### 웹 스크래퍼(Web Scrapper)

- 웹 사이트에서 정보를 추출하는 프로그램

  ex) 상품별 가격을 알기 위해 해당 상품을 파는 페이지들의 가격을 추출

### 웹 크롤링은 불법?

- 웹사이트의 홈디렐토리에 위치한 robots.txt 파일을 열어보고 해당 사이트의 정책을 준수하지 않는다면 불법

- 크롤링한 자료를 상업적인 용도로 사용하면 불법

  ex) 사람인 vs 잡코리아(사람인이 잡코리아 홈페이지에서 채용정보를 크롤링하고 상업적으로 사용)

  ex) 여기어때 vs 야놀자(여기어때가 야놀자의 숙박정보를 크롤링)

  ex) 다나와 : 크롤링한 자료를 상업적인 용도로 사용하면 불법 → 하지만 신고 안함(해당 사이트에서 도움이 돼서?)

- 비상업적인 용도라 하더라도 원작자에게 불이익을 주면 불법

- 크롤러를 활용해 고의적으로 Abusing(데이터 검색이 아니라 다른 형식으로)

### ++

- 학습 목적, 비공개적 자료로 구성된 크롤링 결과의 경우 크게 법적 문제는 없을 것으로 보인다.
- 크롤링 횟수가 많아지면 트래픽에 부담이 가는 경우.
  - 예를 들어 데이터를 연속적으로 가져갈 때(ex. 3초에 한번씩)의 경우 트래픽 높아질 확률이 높기 때문에, 불법적인 예시 중 하나로 IP를 바꿔가며 스크래핑하는 경우가 있다.
  - 대체로 부하를 분산시키는 방법으로 처리한다.

<br>

<br>

# `07.30`

# 코드품질

## 코딩 규칙(Coding Convention)

- 프로그래밍 스타일

- 관행 및 방법

- 소스 코드의 가독성을 개선

- 유지보수를 용이

- 공식화 할 수 있고 비공식적으로 할 수도 있다.

- 컴파일로 잡아주는 것은 아님

- 규칙을 정해주는 것들
  - 파일구성(file organization)
  - 들여쓰기(indention)
  - 주석(comments)
  - 선언(declarations)
  - 명령문(statements)
  - 공백(white space)
  - 명명규칙(naming convention)
  - 프래그래밍 관행(programming practices)
  - 프로그래밍 원칙(programing principles)
  - 아키텍쳐 모범 사례

## Case Type

- UPPER_SNAKE

- kebab-case

- lower_snake

- UpperCamelCase

- lowerCamelCase

- PascalCase

## 또 다른

- 들여쓰기(indent)
  - Space vs Tabs
  - 2칸, 3칸, 4칸, ...

- 중괄호(Brace)
  - 옆 vs 밑

### 코드 확인할 때

- White space changes 체크

- 잘 맞춰줘야 확인할 때 좋음

<br>

# AWS 설정 팁

## SSH 접속

- Putty
- MobaXterm
  - 한번 서버에 접속하게 되면 다시 켰을때 저장 되어있음

## DB 설정

- MySQL
  - AWS 호스트에 설치가 됨 → 도커 컨테이너에 접속할 필요 없이 host에서 MySQL 접속, 이용 가능
  - 외부에서 접속하기 위해서는 설정 필요(net tools)
  - - 권한 부여를 해줘야 접근 가능
  - SSH tunneling : SSH 포트를 통한 접근
- Docker MySQL
  - 컨테이너에 접속해야한다.
  - 다른 설정 없이 외부에서 바로 접속 가능

<br>

<br>

# `08.02`

## 현업에서 프로세스 위반 행위

1. 직접 AWS EC2 서버에 소스를 올리는 행위

- 어플리케이션이 에러가 났을 경우 코드 적합성 문제(깃랩과 서버 코드가 다를 수 있음)

1. Master(Main) 브런치에 직접 소스를 commit 하는 행위

<br>

<br>

# `08.02`

# 프로젝트 성공을 위해

요구사항

수행인력

사업범위

## 대표적인 프로젝트 실패 사례

1. 기능 : 요구사항에 대한 의도 파악 실패
2. 품질 : 결과물의 퀄리티 부족
3. 비용초과 : 시간적, 금전적 손실

## 결과론적 분석

요구사항 해석의 문제

기술력 부족

범위/일정/비용 산정 실패

시간 부족

사용자 참여의 부족

불완전한 요구사항 및 스펙

## 시스템적 분석

결과론적 분석을 통해 도출된 원인에 대해 해당 의사결정을 내린 이유에 대한 분석

패배의 원인이 된 악수를 찾을 뿐만 아니라 악수를 선택한 이유를 분석

의사 결정 과정에 대한 체크리스트 작성

- 이 목록의 항목을 간과하거나 무시하게 된 요인이 있었는가
- 목록의 내용이나 분석 방법을 어떻게 바꾸어야 향후에 같은 실수를 저지르지 않을 수 있는가

결과론적 분석과 동시에 시스템적 분석을 위한 의사결정 방식을 고민하고 점검

## 피드백을 통한 스토리텔링

요구사항에 대한 피드백

Report(보고)보다는 Rapport(동의, 공감)을 통한 의사소통

그래도 안 알려주면? 예측하고 확인하기

- 의도를 알 수 없는 경우에도 의도를 찾자 → 확인하기 중요!

요구사항에 대한 피드백 → 실패 비용의 최소화

<br>

<br>

# `08.04`

# 테스트케이스

테스트케이스는 Test Condition을 확인하기 위한 것임(ISTQB Syllabus FL : 표준)

테스트케이스 : 분기에 따라 결과가 명확하게 갈림

체크리스트 : 단순히 결과가 나옴

## 테스트 베이시스(Test Basis)

정의 : 테스트케이스를 만들기 위한 근거(데이터)

### 명세 기반 베이시스

- 문장(Text)로 이루어진 내용
- ex) 기능 설명서, 사용자 스토리

### 구조 기반 베이시스

- 코드, 제어 흐름도 등의 구조적 데이터로 이루어진 내용
- ex) 단위 코드, 제어 흐름도

## 조건, 결과의 정리

조건은 Y/N으로 나눌 수 있도록 기술

- Decision Table(결정 테이블)

## 정리

- 명세에서 Condition을 도출하여 "조건" 및 "예상결과"로 정리한다.
- 정리 시 조건은 결과가 Yes/No로 정리되도록 한다.
- "조건"부분들의 모든 조합을 구하고 이에 상응하는 예상 결과를 표로 만든다.
- 각 항목을 보면서 하나로 합칠 수 있는 부분을 합치고 있을 수 없는 부분은 삭제하면서 정리한다.

## 제어흐름도

제어 흐름을 모두 커버하는 테스트 케이스

- 코드, 플로우차트 등을 베이스로도 테스트 케이스를 만들 수 있다.(더 쉽다)
- 코드의 테스트 케이스 제작은 if 구문을 커버할 지, 구문 내 조건의 모든 조합을 커버할지 선택해야 한다.
- 제어 흐름도는 Condition의 In VS Out의 조합을 모두 커버해야 한다.

<br>

<br>

# `08.06`

# 웹 서버 보안

## Privilege Escalation

- 낮은 권한을 가진 사용자에서 시작해서 시작해서 높은 권한을 가진 사용자까지 권한을 높이는 공격 방법
- 주로 운영 체제의 보안 취약점을 이용한다.
- 흔히 '쉘 따기' 라고 부른다.
- 오래된 운영 체제를 사용하고 있다면 너무나 쉽게 공격 받을 수 있다.
- 개발자 입장에서는 운영 체제를 최신화 하는 일이 매우 귀찮고 피곤한 일이지만 그냥 두게 되면 잠재적 폭탄을 방치하는 것과 같다.

## ACL(Access Control List)

- 실무에서 많이 사용

- 접근 제어 목록

- 허용하는 IP에 대해서만 접근을 허용한다.

- inbound 뿐만 아니라 outbound도 매우 중요함!(결국 데이터는 바깥으로 나가기 때문에)

- inbound가 열려있고, 공격자가 심은 파일이 서버에서 동작한다고 하더라고 outbound만 제대로 막아두었다면 정보가 외부로 유출되지 않는다.

- 중요한 고객 데이터 등은 사내에서도 허가 받은 IP로만 접근이 가능하도록 제한해야 한다.

  ex) 현장 데이터에 접근하기 위해서는 사전에 신청을 하고 결재를 받은 뒤에 제한된 출입 구역에 들어가서 접속

## ubuntu - ufw

- AWS의 security group rules ⇒ 인스턴스 외부에서 설정

  - 인스턴스 내부에서는 ubuntu ufw를 이용 가능

  ```bash
  sudo ufw status
  ```

- Uncomplicated FireWall

- 나도 차단당할 수 있기 때문에 사용에 주의를 기울여야 한다.

- 보안이 중요한 서버라면 정해진 ip 외에는 접속을 차단해야 한다.

## 인증(Authentication)과 인가(Authorization)

### 인증 : 유저가 누구인지 확인하는 절차

클라이언트가 자신이 주장하는 사용자와 같은 사용자인가?

### 인가 : 유저에 대한 권한을 허락하는 것

클라이언트가 하고자 하는 작업이 해당 클라이언트에게 허가된 작업인가?

<br>

<br>

# `08.13`

# 코딩 테스트

결정(Decision) : OOO 기능을 하도록 코드를 짠다.

피드백(Feedback) : 잘 만든 함수인가?

함수를 완성하고 여기에 피드백을 받을 테이스 케이스를 만든다.

## 테스트를 어렵게 만드는 것?

### 불확실성

: 임의의 값, 임의의 시간 등이 필요한 경우

- 전역 변수, API서버로부터 받는 값 등

### 부수 작업

- DB에 기록을 하는 거스
- 메일 발송
- 시스템 외부에 뭔가를 던지지만 리턴값이 없는...

## TDD의 장, 단점

### 장점

- 디자인 패턴을 의식하지 않고 어느 정도 이에 따른 코드 결과물을 만들 수 있다.
- 테스트 코드 고민이 줄어든다(결정과 피드백의 거리가 좁아짐)

### 단점

- 테스트 케이스의 퀄리티에 따라 결과물이 달라진다.
- 발상의 전환에 시간이 걸린다.

<br>

<br>

# `08.17`

# 산업 혁명

1차 산업 혁명(18세기) : 증기기관(열에너지 → 운동 에너지) 발명

2차 산업 혁명(19세기 ~ 20세기)  : 석유와 전기

3차 산업 혁명(정보화, 자동화 혁명) : 반도체

산업 혁명 시기 ⇒ 노동력 대비 획기적으로 생산성 증가

4차 산업 혁명 : AI, 블록체인, 빅데이터, IoT, 무인 운송 수단

<br>

<br>

# `08.18`

# OWASP와 시큐어 코딩

## 시큐어 코딩

상용화 하려면 필수

한국인터넷진흥원에서 인가를 받아야 함

## OWASP

### SQL injection

가장 많이 발생 → 막으려면 들어오는 데이터를 철저하게 검증

### 데이터 검증

프론트단에서 유효성 검사는 뚫을 수 있다. → 백에서도 해줘야 함

개인정보는 암호화 해줘야 함(되도록 DB에서 암호화) → 해쉬 함수 이용

- Crypthography

  복호화가 안되면 어디에 사용? → 검증(T or F)

  ex) 비밀번호 찾기를 하면 알려주는 것이 아니라 새로 만들라고 함

## SECURE CODING

1. 스트링 비교 시 string.equals("")대신에 "".equals(string)사용

   - 에러의 70% 이상은 null exception이고 이를 방지하기 위해 사용

2. @RequestBody 바인딩 되는 부분을 JPA Entity 객체로 받으면 안됩니다.

   - Entity는 DB에 바로 assign된다고 생각 → DTO를 만들어서 원하는 값만 꺼내서 쓰는 것 추천

     Map<String, Object>를 사용하고 하나씩 꺼내 준다.


<br>

<br>

# `08.19`

# 캐시

## 좋은 AP

높은 신뢰성

보안

처리 속도 / 성능

편리한 UX

## 캐시

데이터나 값을 미리 복사해 놓는 임시 장소

원본 데이터를 접근하는 시간이 캐시의 접근 시간에 비해 오래 걸리는 경우

복잡한 수식을 재연산하는 시간을 절약하고 싶은 경우

캐시에 데이터를 미리 복사해 놓으면 계산, 접근 시간 없이 빠른 속도로 데이터에 접근 가능