# `07.27`

# 개발자의 나쁜 습관

## 코드 관리

### 가독성

20줄을 2 ~ 3줄로 줄이는 것은 좋지만 가독성을 생각하면서 !

코드의 접근성을 먼저 생각하고 똑똑한 코드는 그 다음에 생각

### 바이트를 줄이자

웹 사이트 크기를 수 바이트 줄이는 게 그렇게 중요한지?

더 중요한 요구사항들이 있지 않은지

최적화는 프로젝트의 가장 마지막에

요구사항이 바뀌면 그 앞에 해왔던 최적화들은 쓰레기가 된다.

### 코딩 스타일

코딩 스타일을 지키지 않으면 진행하기 어려운 프로젝트가 된다.

작은 부분이라도 스타일은 꼭 지키자

### 작은 오류 로그는 무시

예외를 무시하든 에러를 보고하지 않는 라이브러리를 쓰든 오류 가능성을 숨기는 방법은 여러 가지가 있다. 하지만 이 중 하나라도 주요 이슈가 터지면 그걸 고치는데 몇 배의 시간이 걸린다.

### 변수명

이름만 잘 지어도 코드를 알아보는데 걸리는 시간을 1시간에서 10초로 줄일 수 있다.

### 개발자 툴과 IDE 사용법 미숙

핫키, 단축키, 환경 세팅은 생각보다 더 중요

이것을 익힘으로써 코딩의 context를 바꾸는 게 중요함

익숙해져야 비로소 코드 그 자체에 집중할 수 있게 된다.

개발 스타일에 따라 잘 맞는 IDE가 있다.

Vscode, Subime text, Eclipse, Intellij 등

### 눈 감고 소스 코드 복붙

코드 재사용 전에는 꼭 한번은 꼼꼼히 읽어 볼 것

안 읽고 복붙 했다가 장애 발생시 조치시간은 길어짐

나중에라도 꼭 읽어보기

### 라이브러리

예제 몇 개 봤다고 새 라이브러리를 마스터할 수는 없다.

직접 써보고 분석하면서 익히는 것들이 분명히 있다.

<br>

## 팀워크

### 계획을 자주 바꾸기

프로젝트를 망하게 만드는 가장 쉬운 방법

무분별한 계획 변경은 일정지연 및  개발기간 부족으로 이어짐

### 계획 고집

계획을 바꾸는 것도 나쁘지만, 실현 불가능한 계획을 고집하는 것도 나쁘다.

항상 아이디어를 팀과 공유하고 피드백을 받고 막혔을 땐 조언을 받자

### 혼자 일하기

프로젝트 진행현황, 아이디어 등은 팀과 항상 공유해야 한다.

팀원들과의 지속적인 대화는 본인뿐만 아니라 팀원들에게도 도움이 된다.

### 나쁜 코드 짜기를 거부한다.

나쁜 코드 : 프로젝트 마감 일에 쫓겨 작동만 가능하도록 급조하여 만든 엉망인 코드

나쁜 코드라도 빠르게 짤 수 있는 능력도 필요함(실제로 많이 일어나는 일)

꼭 짜라는 것이 아니라 상황에 따라 짤 수도 있어야 한다.

### 본인의 실수를 인정하지 않는 것

전문가는 자기 분야에 거만해지기 마련

자만심, 자존심에 눌려 쌓아온 신뢰를 깎아 먹는 게 두려워 자신의 실수를 인정하지 않는 것이 진짜 실수

### 내가 배운 것을 공유하지 않는 것

개발자로서의 가치는 코드로만 보여지는 게 아님

코드를 짜면서 당신이 무얼 배웠는지, 경험을 공유하고, 왜 그렇게 짰는지를 설명하는 과정들이 본인을 스킬업 시킨다.

### 늦은 피드백

팀원 모두가 동일한 정보를 공유하고 있는 상태(on the same page)로 만들어야 한다.

팀워크의 기본

### 내 코드에 집착하기

나의 코드에 딴지를 거는거지 나한테 딴지를 거는 건 아니다.

왜 그렇게 짰는지 잘 설명하고, 더 나은 방법이 있다면 받아들이는 게 이득

<br>

## 테스트 및 유지보수

### 통과할 정도의 테스트만 만들기

통과하지 못할 테스트도 만들어야 한다.

그래야 프로젝트가 진행되고 이슈 tracking이 가능해진다.

### 기능 구현 이외의 사항을 무시

기능 구현에만 몰두하다 보면 성능, 보안 등의 문제를 소홀히 하기 쉽다.

이외의 사항은 checklist에 적어두고 관리

⇒ 좋은 방법이 좋은 습관이 되면 매 상황마다 좋은 방법을 찾을 필요가 없다.

<br>

<br>

# `07.28`

# 관심사 분리

어떤 로직을 해야하는지 메소드를 정의하고 위에서 아래로 정의해나감

## 코드 레벨의 관심사 분리

다른 함수에서 어떤 일을 하는지 관심이 있는가

각 함수에서 수정이 필요할 때 다른 함수에 영향을 미치는가

내가 알아야 하는 건 오직 내가 호출하는 녀석뿐

표현 계층의 코드는 Human Readable 해야한다.

### 위의 관심사 분리를 반영한 스프링의 계층 분리

- 주니어 개발자도 쉽게 기능 개발을 위해서 투입될 수 있다.
- 코드를 이상하게 짰다고 해서 다른 계층과 기능으로 전파되지 않는다.
- 문제가 생겨도 문제가 생긴 지점을 찾기 쉽다.
- 엔터프라이즈 코드(스프링 내부가 어떻게 작동하는지)가 어떻게 동작하는지는 개별 개발자의 관심사가 아니다.
- 대규모 프로젝트 개발에 유리하다.

Servlet filter 2

Controller 1

Service 3

Repository 4

- 숫자는 호출 순서

<br>

## 개발자 간의 관심사도 분리할 수 있다.

프론트/백엔드 엔드가 아직 안나와서 테스트를 못하는데요(교착 상태)

API를 정의하는 이유가 무엇일까?

관심사가 제대로 분리되고 API를 정의했다면 발생 안함

→ API를 정의한 뒤에 제대로 동작하지 않는 것은 각 개발자의 책임

→ API를 만들 때까지 치열한 논의와 토론은 중요하다.

### 스웨거를 많이 사용한다.

- API 개발 도구로 인터페이스를 정의하고 인터페이스에 맞게 개발을 하기 위해서 사용하는 도구

<br>

## 블랙박스식 개발

Input → Some Module → Output

모듈이 어떻게 구현되었는지를 보지 않고 Input과 Output에 대해서만 관심을 두는 것을 블랙박스식 개발이라고 한다.

관심사 분리를 하기 위해서는 블랙박스식 개발이 필수

오직 관심을 가져야 할 것은  Input과 Output을 정의하고 그것이 정상적으로 동작하느냐이다.

### 블랙박스식 개발의 장점

리팩토링에 유리하다(테스트 코드는 여기에 사용한다)

병목 지점을 찾아내는 것이 쉽다.

기능의 분리가 쉽다.

성능 개선 시 개선 부분을 찾는 것이 쉽다.(ex. 걸리는 시간을 각각 측정)

### 리펙토링 코드 테스트

Input에 대해서 Output이 잘 나왔으면 성공

### 동시 접속자가 많은 사이트

MSA구조로 설계

앞쪽 노드밸런서를 놓고 게이트웨이를 통해 API서버를 연결, DB로 부터 쿼리를 받아오는 방식

<br>

## 관심사 분리를 하면?

장애가 발생해도 그것이 전파되지 않는다.

새로운 관심사를 추가하는 것이 쉽다.

관심사마다 한정된 자원을 할당할 수 있다.

MSA(Micro Service Architecture)의 근간이 된다.

<br>

<br>

# `07.29`

# 데이터 크롤링

## 인터넷에서 데이터를 수집하는 방법

1. OpenAPI 등 공개된 API를 사용
   - 공공데이터 포털
   - NaverDevelopers
2. HTTP GET Method
   - 정보가 게시되어 있는 대상 웹사이트를  HTTP Get을 사용하여 html 코드를 얻고 Text Parsing해서 사용
   - Java / Go / Python 등 대부분에서 사용
3. Selenium Web Driver
   - 사람이 하는 것과 유사한 자동화 방법
   - 웹브라우저 인스턴스를 생성해 실행 시킨 후 해당 인스턴스를 컨트롤
     - 커맨드를 날려서 브라우저를 컨트롤
   - 웹사이트 테스트 자동화 목적으로 개발
   - 많이 사용하는 방법
   - 가상의 브라우저를 실행시키는 Haedless Mode(실제로 브라우저를 띄우지 않고 가상으로  띄움) 등이 있음 → 이것보다는 실제로 띄워서 하는 것이 빠름
4. 사람이 수작업으로 데이터를 수집하는 방법

## 웹 크롤러 vs 웹 스크래퍼

- 여러 사이트를 돌아다니면서 필요한 데이터를 가지고 오는 것 vs 고정된 형상에서 데이터를 가져옴
- 크롤러보다는 대부분 단순 스크래퍼 개발 수요가 많음
- 우리나라에서는 많은 기업들이 같은 의미로 혼용

### 웹 크롤러(Web Crawler)

- 조직적, 자동화 된 방법으로 웹을 탐색/수집 하는 프로그램

  ex) 구글, 네이버 등의 검색엔진 결과 데이터를 수집하기 위한 봇(Bot)

- API 호출로 데이터를 받는 것은 크롤링이 아님

### 웹 스크래퍼(Web Scrapper)

- 웹 사이트에서 정보를 추출하는 프로그램

  ex) 상품별 가격을 알기 위해 해당 상품을 파는 페이지들의 가격을 추출

### 웹 크롤링은 불법?

- 웹사이트의 홈디렐토리에 위치한 robots.txt 파일을 열어보고 해당 사이트의 정책을 준수하지 않는다면 불법

- 크롤링한 자료를 상업적인 용도로 사용하면 불법

  ex) 사람인 vs 잡코리아(사람인이 잡코리아 홈페이지에서 채용정보를 크롤링하고 상업적으로 사용)

  ex) 여기어때 vs 야놀자(여기어때가 야놀자의 숙박정보를 크롤링)

  ex) 다나와 : 크롤링한 자료를 상업적인 용도로 사용하면 불법 → 하지만 신고 안함(해당 사이트에서 도움이 돼서?)

- 비상업적인 용도라 하더라도 원작자에게 불이익을 주면 불법

- 크롤러를 활용해 고의적으로 Abusing(데이터 검색이 아니라 다른 형식으로)

### ++

- 학습 목적, 비공개적 자료로 구성된 크롤링 결과의 경우 크게 법적 문제는 없을 것으로 보인다.
- 크롤링 횟수가 많아지면 트래픽에 부담이 가는 경우.
  - 예를 들어 데이터를 연속적으로 가져갈 때(ex. 3초에 한번씩)의 경우 트래픽 높아질 확률이 높기 때문에, 불법적인 예시 중 하나로 IP를 바꿔가며 스크래핑하는 경우가 있다.
  - 대체로 부하를 분산시키는 방법으로 처리한다.

<br>

<br>

# `07.30`

# 코드품질

## 코딩 규칙(Coding Convention)

- 프로그래밍 스타일

- 관행 및 방법

- 소스 코드의 가독성을 개선

- 유지보수를 용이

- 공식화 할 수 있고 비공식적으로 할 수도 있다.

- 컴파일로 잡아주는 것은 아님

- 규칙을 정해주는 것들
  - 파일구성(file organization)
  - 들여쓰기(indention)
  - 주석(comments)
  - 선언(declarations)
  - 명령문(statements)
  - 공백(white space)
  - 명명규칙(naming convention)
  - 프래그래밍 관행(programming practices)
  - 프로그래밍 원칙(programing principles)
  - 아키텍쳐 모범 사례

## Case Type

- UPPER_SNAKE

- kebab-case

- lower_snake

- UpperCamelCase

- lowerCamelCase

- PascalCase

## 또 다른

- 들여쓰기(indent)
  - Space vs Tabs
  - 2칸, 3칸, 4칸, ...

- 중괄호(Brace)
  - 옆 vs 밑

### 코드 확인할 때

- White space changes 체크

- 잘 맞춰줘야 확인할 때 좋음

<br>

# AWS 설정 팁

## SSH 접속

- Putty
- MobaXterm
  - 한번 서버에 접속하게 되면 다시 켰을때 저장 되어있음

## DB 설정

- MySQL
  - AWS 호스트에 설치가 됨 → 도커 컨테이너에 접속할 필요 없이 host에서 MySQL 접속, 이용 가능
  - 외부에서 접속하기 위해서는 설정 필요(net tools)
  - - 권한 부여를 해줘야 접근 가능
  - SSH tunneling : SSH 포트를 통한 접근
- Docker MySQL
  - 컨테이너에 접속해야한다.
  - 다른 설정 없이 외부에서 바로 접속 가능

<br>

<br>

# `08.02`

## 현업에서 프로세스 위반 행위

1. 직접 AWS EC2 서버에 소스를 올리는 행위

- 어플리케이션이 에러가 났을 경우 코드 적합성 문제(깃랩과 서버 코드가 다를 수 있음)

1. Master(Main) 브런치에 직접 소스를 commit 하는 행위

<br>

<br>

# `08.02`

# 프로젝트 성공을 위해

요구사항

수행인력

사업범위

## 대표적인 프로젝트 실패 사례

1. 기능 : 요구사항에 대한 의도 파악 실패
2. 품질 : 결과물의 퀄리티 부족
3. 비용초과 : 시간적, 금전적 손실

## 결과론적 분석

요구사항 해석의 문제

기술력 부족

범위/일정/비용 산정 실패

시간 부족

사용자 참여의 부족

불완전한 요구사항 및 스펙

## 시스템적 분석

결과론적 분석을 통해 도출된 원인에 대해 해당 의사결정을 내린 이유에 대한 분석

패배의 원인이 된 악수를 찾을 뿐만 아니라 악수를 선택한 이유를 분석

의사 결정 과정에 대한 체크리스트 작성

- 이 목록의 항목을 간과하거나 무시하게 된 요인이 있었는가
- 목록의 내용이나 분석 방법을 어떻게 바꾸어야 향후에 같은 실수를 저지르지 않을 수 있는가

결과론적 분석과 동시에 시스템적 분석을 위한 의사결정 방식을 고민하고 점검

## 피드백을 통한 스토리텔링

요구사항에 대한 피드백

Report(보고)보다는 Rapport(동의, 공감)을 통한 의사소통

그래도 안 알려주면? 예측하고 확인하기

- 의도를 알 수 없는 경우에도 의도를 찾자 → 확인하기 중요!

요구사항에 대한 피드백 → 실패 비용의 최소화

<br>

<br>

# `08.04`

# 테스트케이스

테스트케이스는 Test Condition을 확인하기 위한 것임(ISTQB Syllabus FL : 표준)

테스트케이스 : 분기에 따라 결과가 명확하게 갈림

체크리스트 : 단순히 결과가 나옴

## 테스트 베이시스(Test Basis)

정의 : 테스트케이스를 만들기 위한 근거(데이터)

### 명세 기반 베이시스

- 문장(Text)로 이루어진 내용
- ex) 기능 설명서, 사용자 스토리

### 구조 기반 베이시스

- 코드, 제어 흐름도 등의 구조적 데이터로 이루어진 내용
- ex) 단위 코드, 제어 흐름도

## 조건, 결과의 정리

조건은 Y/N으로 나눌 수 있도록 기술

- Decision Table(결정 테이블)

## 정리

- 명세에서 Condition을 도출하여 "조건" 및 "예상결과"로 정리한다.
- 정리 시 조건은 결과가 Yes/No로 정리되도록 한다.
- "조건"부분들의 모든 조합을 구하고 이에 상응하는 예상 결과를 표로 만든다.
- 각 항목을 보면서 하나로 합칠 수 있는 부분을 합치고 있을 수 없는 부분은 삭제하면서 정리한다.

## 제어흐름도

제어 흐름을 모두 커버하는 테스트 케이스

- 코드, 플로우차트 등을 베이스로도 테스트 케이스를 만들 수 있다.(더 쉽다)
- 코드의 테스트 케이스 제작은 if 구문을 커버할 지, 구문 내 조건의 모든 조합을 커버할지 선택해야 한다.
- 제어 흐름도는 Condition의 In VS Out의 조합을 모두 커버해야 한다.

<br>

<br>

# `08.06`

# 웹 서버 보안

## Privilege Escalation

- 낮은 권한을 가진 사용자에서 시작해서 시작해서 높은 권한을 가진 사용자까지 권한을 높이는 공격 방법
- 주로 운영 체제의 보안 취약점을 이용한다.
- 흔히 '쉘 따기' 라고 부른다.
- 오래된 운영 체제를 사용하고 있다면 너무나 쉽게 공격 받을 수 있다.
- 개발자 입장에서는 운영 체제를 최신화 하는 일이 매우 귀찮고 피곤한 일이지만 그냥 두게 되면 잠재적 폭탄을 방치하는 것과 같다.

## ACL(Access Control List)

- 실무에서 많이 사용

- 접근 제어 목록

- 허용하는 IP에 대해서만 접근을 허용한다.

- inbound 뿐만 아니라 outbound도 매우 중요함!(결국 데이터는 바깥으로 나가기 때문에)

- inbound가 열려있고, 공격자가 심은 파일이 서버에서 동작한다고 하더라고 outbound만 제대로 막아두었다면 정보가 외부로 유출되지 않는다.

- 중요한 고객 데이터 등은 사내에서도 허가 받은 IP로만 접근이 가능하도록 제한해야 한다.

  ex) 현장 데이터에 접근하기 위해서는 사전에 신청을 하고 결재를 받은 뒤에 제한된 출입 구역에 들어가서 접속

## ubuntu - ufw

- AWS의 security group rules ⇒ 인스턴스 외부에서 설정

  - 인스턴스 내부에서는 ubuntu ufw를 이용 가능

  ```bash
  sudo ufw status
  ```

- Uncomplicated FireWall

- 나도 차단당할 수 있기 때문에 사용에 주의를 기울여야 한다.

- 보안이 중요한 서버라면 정해진 ip 외에는 접속을 차단해야 한다.

## 인증(Authentication)과 인가(Authorization)

### 인증 : 유저가 누구인지 확인하는 절차

클라이언트가 자신이 주장하는 사용자와 같은 사용자인가?

### 인가 : 유저에 대한 권한을 허락하는 것

클라이언트가 하고자 하는 작업이 해당 클라이언트에게 허가된 작업인가?

<br>

<br>

# `08.13`

# 코딩 테스트

결정(Decision) : OOO 기능을 하도록 코드를 짠다.

피드백(Feedback) : 잘 만든 함수인가?

함수를 완성하고 여기에 피드백을 받을 테이스 케이스를 만든다.

## 테스트를 어렵게 만드는 것?

### 불확실성

: 임의의 값, 임의의 시간 등이 필요한 경우

- 전역 변수, API서버로부터 받는 값 등

### 부수 작업

- DB에 기록을 하는 거스
- 메일 발송
- 시스템 외부에 뭔가를 던지지만 리턴값이 없는...

## TDD의 장, 단점

### 장점

- 디자인 패턴을 의식하지 않고 어느 정도 이에 따른 코드 결과물을 만들 수 있다.
- 테스트 코드 고민이 줄어든다(결정과 피드백의 거리가 좁아짐)

### 단점

- 테스트 케이스의 퀄리티에 따라 결과물이 달라진다.
- 발상의 전환에 시간이 걸린다.

<br>

<br>

# `08.17`

# 산업 혁명

1차 산업 혁명(18세기) : 증기기관(열에너지 → 운동 에너지) 발명

2차 산업 혁명(19세기 ~ 20세기)  : 석유와 전기

3차 산업 혁명(정보화, 자동화 혁명) : 반도체

산업 혁명 시기 ⇒ 노동력 대비 획기적으로 생산성 증가

4차 산업 혁명 : AI, 블록체인, 빅데이터, IoT, 무인 운송 수단

<br>

<br>

# `08.18`

# OWASP와 시큐어 코딩

## 시큐어 코딩

상용화 하려면 필수

한국인터넷진흥원에서 인가를 받아야 함

## OWASP

### SQL injection

가장 많이 발생 → 막으려면 들어오는 데이터를 철저하게 검증

### 데이터 검증

프론트단에서 유효성 검사는 뚫을 수 있다. → 백에서도 해줘야 함

개인정보는 암호화 해줘야 함(되도록 DB에서 암호화) → 해쉬 함수 이용

- Crypthography

  복호화가 안되면 어디에 사용? → 검증(T or F)

  ex) 비밀번호 찾기를 하면 알려주는 것이 아니라 새로 만들라고 함

## SECURE CODING

1. 스트링 비교 시 string.equals("")대신에 "".equals(string)사용

   - 에러의 70% 이상은 null exception이고 이를 방지하기 위해 사용

2. @RequestBody 바인딩 되는 부분을 JPA Entity 객체로 받으면 안됩니다.

   - Entity는 DB에 바로 assign된다고 생각 → DTO를 만들어서 원하는 값만 꺼내서 쓰는 것 추천

     Map<String, Object>를 사용하고 하나씩 꺼내 준다.


<br>

<br>

# `08.19`

# 캐시

## 좋은 AP

높은 신뢰성

보안

처리 속도 / 성능

편리한 UX

## 캐시

데이터나 값을 미리 복사해 놓는 임시 장소

원본 데이터를 접근하는 시간이 캐시의 접근 시간에 비해 오래 걸리는 경우

복잡한 수식을 재연산하는 시간을 절약하고 싶은 경우

캐시에 데이터를 미리 복사해 놓으면 계산, 접근 시간 없이 빠른 속도로 데이터에 접근 가능

### 캐싱에 적합한 대상

Read가 빈번하고 Write는 거의 없는 경우

메모리는 매우 중요한 자원, 신중, 선별적 캐싱 정책이 중요

Out of Memory → 이것만큼은 피할 수 있도록 조심!!

### TTL

보통 캐싱된 데이터에는 만료시간 및 갱신 주기가 존재함

데이터 sync.는 매우 중요!

```jsx
<expiry>
	<ttl unit="minutes">5</ttl>
</expiry>
```

### 캐싱 적용

메뉴 목록을 하드 코딩하지는 않을 듯

메뉴 데이터는 DB에 존재한다고 가정

사용자가 요청이 많아질수록 DB 조회가 많아진다.

### 직접 구현

메모리에 특정 객체를 생성한 후 캐싱하고자 하는 데이터를 저장

단 해당 프로세스에서 유일한 저장 장소가 되도록 잘 선언해서 사용(싱글톤 패턴)

List menuList = new ArrayList();

menuList=selectMenuListFromDB();

- 예시

클러스터를 고려해야한다.

- 예시

### EHCache

로컬 캐시 라이브러리

WAS n대 클러스터링 되어 있다면 동기환 이슈 발생

WAS간 내부 통신을 통해 동기화 작업 선행

EHCache가 지원하는 RMI 활용한 클러스터링 설정 가능

### 캐시 적용기

DB로 방송 편성 데이터 상품 정보 관리

별도의 서버/솔루션 설치는 불가한 상황

성능 향상을 위해 메모리 캐싱 정책을 고려중임

- 웹 어플리케이션에 메모리 저장소 객체 구현
- 일별 상품 데이터를 리스트, 맵의 형태로 저장(캐싱)
- 갱신 주기 설정 가능, 해당 주기 마다 캐싱 전체 삭제 후 DB로부터 새로운 상품 데이터 조회 및 저장
- 방송 예정된 상품은 캐시 저장소로부터 조회될 수 있도록 해당 서비스 수정
- 기존 서비스에서 상품 정보를 수정하는 트랜잭션 수행 시 해당 캐시 내역도 동시에 수정하도록 로직 변경

### Redis

NoSQL&Cache 솔루션, 메모리 기반으로 구성

in-memory DB

데이터베이스로 사용될 수 있으며 Cache로도 사용될 수 있는 기술

### 캐싱 실전 적용

Cache의 기본적인 개념 파악

웹 AP 작성 코드에 DB 연동 조회 결과값을 특정 객체에 저장

로컬 캐시 적용해보기

In-memory DB 솔루션 Redis 경험해보기

<br>

<br>

# `08.31`

# Python Web Framework

ex) 인스타, 넷플릭스가 Python으로 Backend 사용

Django, Flask, FastAPI

## Django

- 효율적이고 파워풀한 내부 패키지 기능
- Model-Template-View 패턴
- Djangoo REST Framework(DRF)로 쉽게 RESTful API 구축
- 강력한 보안
- 고성능 사이터 대응으로 주로 대형기업이나 테크기업에서 사용
- 국내에서는 요기요, 코잇빗 등이 사용

## Flask

- 마이크로 프레임워크로 경량 프레임워크
- 유연함, 심플, 쉬운 확장
- 쉬운 학습 및 러닝 커브 낮음
- 높은 생산성
- NoSQL 사용
- 가볍다 → 개발 이외에 신경 쓸 부분이 많다.
- 구조적으로 한번에 많은 트래픽을 처리하기 힘들다

## Fast API

- 가장 최근에 나온 API(2018년)
- ASGI(Asynchronous Server Gateway Interface)
- Python 3.6 이상 표준
- 고속의 빠른 성능 처리속도

## 비교

|      | Django                                                       | Flask                                                        | FastAPI                                                      |
| :--- | :----------------------------------------------------------- | :----------------------------------------------------------- | ------------------------------------------------------------ |
| 장점 | 대규모 트래픽 처리<br>내장된 수많은 강력한 기능<br>보안<br>장고-어드민<br>우수한 문서와 많은 커뮤니티 | 유연함<br>직관적<br>쉬운 학습<br>통합된 테스팅 툴 지원<br>   | 빠른 성능 처리<br>비동기 코드 지원<br>높은 생산력<br>쉬운 TDD 테스트 예외처리, 배포, 문서화 |
| 단점 | 집중화된 URL 루틴 패턴<br>내장된 ORM <br>NOSQL 에 유현하지 않음<br>모놀리식 | 비동기 지원안함<br>대용량 앱에는 적합하지 않음<br>개발자 식력에 따라 코드 품질<br> | 베타버전<br>교육자료 및 커뮤니티가 적음                      |

|      | 장고               | 플라스크            | 패스트api                     |
| :--- | :----------------- | :------------------ | :---------------------------- |
|      | 풀스택             | WSGI                | ASGI                          |
|      | 내장된 다양한 기능 | 완전한 유연성       | 코드 레이아웃을 제한하지 않음 |
|      | 내장된 ORM         | SQLAlchemy, PonyORM | SQAlchemy                     |
|      | 지원하지 않음      | Flask-PyMong        | Pydantic                      |

<br>

<br>

# `09.13`

## 암호화의 핵심

- 안에 있는 내용을 가져가거나 봤을 때에도 사용할 수 없도록 하는 것

- 일반적인 네트워크 통신은 안전하지 않다라고 생각(네트워크 스니핑)

- 단순 token으로 인증을 수행하는 구조에서는 클라이언트(브라우저)와 웹서버 구간을 암호화 하는 건 필수 → `HTTPS 통신은 필수` → SSL 인증서 작업은 이런 이유로 진행이 필요하다.

- Fiddler, Wireshark : http 네트워크 요청 내용을 모니터링 할 수 있다.

- Postman : http 요청을 쉽게 생성하여 보낼 수 있다.

  → 여러번 네트워크 요청을 보내서 합쳐보면 토큰을 알 수 있고 이를 이용하여 Postman으로 호출 시 private한 정보가 그대로 보인다.

## AP 개발자가 하는 일

- 프로그래밍 언어를 사용해서 OS에게 명령을 한다.
- 명령이 의도대로 실행되지 않고 이상하다면
  - 디버깅
  - 타 제품(라이브러리, 프로그램 등)의 로그(log) 확인
  - 버전을 맞춰주는 것이 좋다.
- 웹 서버, WAS 등 사용하는 제품의 로그를 확보해야한다.
  - 'nginx/springboot 로그설정/디렉토리' 등으로 검색해보기

## HTTP

- Hyper Text Transfer Protocol
- Stateless
- HTTP 서버는 불특정 다수의 요청을 전제

<br>

<br>

# `09.14`

# UCC

User Created Contents : 사용자 제작 컨텐츠

## 만드는 이유

- 제품 홍보 UCC
  - 사용자 관점에서 제품에 대해 이해하기 우해
- 자기 PR의 시대
  - 면접관 입장에서의 지원자에 대한 이해

### 꿀팁

- 간략하게 설명하기
- 60초 내에 핵심을 펼치기
- 진지한 이야기에 웃음을 곁들이기
- 목적과 의미 전달하기
- 문제 공유하기

#### 스토리 텔링

- 비유
- 쉬운 표현
- 악당과 영웅(대조되는 상황)
  - 기능 설명은 text가 아닌 그림으로
- 등장인물 외에 스토리를 더욱 극적으로 만드는 것
  - CG
  - BGM

### 누군가 UCC를 본다면?

- 꿈, 열정, 도전 정신 → 즐거움

<br>

<br>

# `09.30`

## 실 서버(운영) 배포시 유의할 점

- 콘솔 출력을 없앤다.
  - 입출력 작업은 버거운 일 → 성능 이슈
- 보안상 문제가 될 만한 것이 없는지 체크
  - 개발 단계부터 고려
  - ex) 업로드 가능 파일 확장자 체크
- 시스템 사용 인증 및 권한 부여가 잘못되지 않았는지 체크
- 저작권 이슈가 있는 리소스가 있는지 체크
  - 라이브러리, 이미지/사운드 등

<br>

<br>

# Flyway

- 각각의 환경에 대한 수동 DB 소요시간이 줄어든다.
- DB 변경 누락으로 인한 오류가 줄어든다.
- 코드 변경과 DB 변경의 추적 개선
- 새로운 DB를 처음부터 만드는 것이 가능하다.
- CI/CD와 통합 적용할 수 있다.

<br>

<br>

# `10.08`

## 개별 체크리스트(트러블슈팅)

1. 운영체제 reboot는 해보았는가?
2. 환경설정에 한글이 문제를 일으키지 않는가?
3. 영문 새소문자 구별 문제는 아닌가?(+ 공백 문자)
4. OS, Language(컴파일러/인터프리터), Library, framework의 버전이 다른건 아닌가?
5. 네트워크 연결은 정상적인가?(port 포함)
6. 캐릭터 인코딩이 문제인가?(utf-8, euc-kr 등)
7. 해당 제품의 로그(log)는 확인했는가?(웹서버, WAS 등)

<br>

<br>

# `10.12`

# 프로젝트를 더 즐기기 위한 방법

## 팀장

- 현업의 팀장보다 더 과중한 역할을 맡고 있는 싸피의 팀장. 가능하다면 팀장을 도와주기
- 팀장의 주 역할은 프로젝트 관리

## 경쟁

- 적당한 경쟁심은 프로젝트 진행에 도움을 준다.
- 과유불급. 경쟁심에 과몰되지 않도록
- 비밀번호 같은 보안 관리는 철저히

## 존중

- 서로를 존중
- 본인이 현재 진행 중인 업무가 없다 하더라도 팀에 기여할 수 있는 부분을 찾아보기

## 협력

- 혼자만의 힘으로는 불가능. 협력은 필수
- 대화와 소통의 스킬이 모두에게 필요
- 팀 구성원들의 장점을 모두 녹일 수 있도록

## 향후

- 지금 사용하는 기술 스택들을 추후 다시 사용할 수 있음
- 당장을 위해서가 아니라 향후 10년, 15년 뒤를 고려하자
- 수상도 좋지만 본인 스스로 발전을 할 수 있도록