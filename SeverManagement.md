# `07.07`

# 서버 관리(Sever Management)

서버의 상태를 관리하기 위한 노력

## 서버 관리 흐름

### 1. 자체 서버 운영

서버 주문 → 서버 설치 → CPU, 메모리, 하드디스크 조립 → 네트워크 연결 → OS설치 → 계정 설정 → 방화벽 설정 → ...

서버를 설정하기 위해  많은 노력과 시간이 필요

성능이 좋은 걸 미리 구매하고 효율적인 사용을 위해 여러 애플리케이션을 설치

명령어를 까먹으면 어떻게 하는지 알 수 없고 그전 사람이 어떻게 했는지 알 수 없음

### 2. 상태 관리 도구

설정을 보고 프로그램이 대신 설치해줌

코드를 보고 알 수 있고 버전 관리 가능

- 코드로 작성하면 협업과 버전 관리 가능
- 어렵다.. 여러 버전을 설치하려면 어렵다

### 3. 가상머신

**Jenkins, Woedpress, Chat**

한 서버에 여러 개 설치 가능

현재 상태를 저장 가능

처음부터 다시 셋팅은 어떻게 하지?(과정을 기록하고 있지 않음)

이미지 공유를 어떻게 하지?(용량이 큼)

속도가 느림

### 4. 클라우드

**AWS, Google Cloud, Azure**

하드웨어 파편화 문제 해결

가상화된 환경만으로 아키텍처 구성이 가능

이미지를 기반으로한 다수의 서버 상태 관리

- 상태 관리에 대한 새로운 접근
- 서버 운영의 문제는 그대로 있음(누군가가 관리 해줘야함)

### 5. PaaS

**Heroku,Netlify, AWS Elastic Beanstalk, Google Cloud App Engine**

**장점**

- 서버를 운영하는 것은 복잡하고 어렵다 → 소스 코드만으로 배포가 가능(인프라를 몰라도 소스코드로 배포 가능) → 너무 쉽다.
- 일반화된 프로비저닝 방법을 제공
  - 프로비저닝 과정에 개입할 수 없음(커스터마이징 불가)
  - 쉬워서 굳이 인프라를 알아야하나? 라는 의심이 들 수 있음

**단점**

- 애플리케이션을 PaaS 방식에 맞게 작성해야함
- 서버에 대한 원격 접속 시스템을 제공하지 않음
- 서버에 파일 시스템을 사용할 수 없음
- Site 패키지를 설치할 수 없음
- 로그 수집을 제한적인 방식으로 허용(STDOUT)
- 애플리케이션 배포에 대한 새로운 패러다임 공부 필요
- PaaS에서 할 수 있을까?

### 6. `Docker`

서버관리와 개발 방식을 완전히 바꿈

복잡한 배포나 설정을 쉽게 가능

하나의 명령어로 쓸 수 있다.

- 컨테이너로 만들 수 있다. → 서버 관리 혁신
  - 컨테이너만 있으면 도커 명령어로 실행 가능
- 어디서든 돌아간다.
  - 모든 클라우드에서 사용 가능
- VM vs Docker
  - 가상머신처럼 독립적으로 실행되지만 가상머신보다 빠르고 가상머신보다 쉽고 가상머신보다 효율적으로 사용이 가능하다.
  - 기존에는 윈도우 위에 리눅스를 올렸지만 도커는 게스트OS가 없고 옆의 프로그램이 모르게 격리를 한다.
  - OS를 쓰게되면 OS에서 사용하는 CPU, Memory 사용량이 있는데 도커는 단순히 격리를 해주기 때문에 OS가 실행될 필요가 없음 → 속도가 빠름

- 자원격리(고급기능) 가능(이 프로그램이 실행 되었을 때 다른 프로그램이 모르게 하는 것)
  - 프로세스를 가상으로 분리
  - 파일, 디렉토리를 가상으로 분리
  - CPU, Memory, I/O를 그룹별로 제한
  - 리눅스 기능을 이용한 빠르고 효율적인 서버 관리가 가능했지만 기술이 어려웠음

#### 도커가 가져온 변화

- 클라우드 이미지보다 관리하기 쉬움
- 다른 프로세스와 격리되어 가상머신처럼 사용하지만 성능 저하가 거의 없음
- 복잡한 기술(namespace, cgroups, network, ...)을 몰라도 사용할 수 있음
- 이미지 빌드 기록이 남음
- 코드와 설정으로 관리 → 재현 및 수정 가능
- 오픈 소스 → 특정 회사 기술에 종속적이지 않음

#### 실행까지는 편한데 배포는 어떻게 할까?

1. 배포는 어떻게 할까?

   각각의 서버에 접속하여 업데이트 해야 하는 문제점

   어느 서버가 여유가 있는지 확인하기 힘듬

   버전 업/다운이 손이 많이 감(각각 접속해서 해야 하기 때문)

2. 서비스 검색은 어떻게 할까?

   사용자들은 프록시 서버에 접속

   사람들이 많아지면 프록시에서 바라보는 서버를 추가해줘야 함 → 마이크로 서비스가 되면 하나하나 설정하기 어려워짐

3. 서비스 노출은 어떻게 할까?

   www, blog, admin ... 등에 따라 분류해줘야하는데 자동으로 하는 방법이 있으면 좋겠다.

4. 서버에 부하가 생겼을 때 어떻게 할까?

   여러 개 중에 한, 두개가 꺼졌을 때도 돌아가고 있기 때문에 서버에 문제가 생기면 바로 알려주는 것이 필요하다.

⇒ 이를 효과적으로 관리하기 위한 도구가 필요 ⇒ `Container Orchestration`

#### Container Orchestration

도커가 나오면서 서버 관리가 편해졌음 → 컨테이너가 많아지면 서버가 컨테이너 하나하나를 관리해주기 어려움 → 대신해주는 오케스트레이션이 나왔다 !

복잡한 컨테이너 환경을 효과적으로 관리하는 도구

- 컨테이너 오케스트레이션

### 7. `Kubernetes`

여러가지의 오케스트레이션이 나왔지만 그 시기(춘추전국시대 - DEIS, RANCHER, NOMAD ...)를 지나고 나옴

컨테이너를 `쉽고 빠르게 배포/확장`하고 `관리를 자동화`해주는 오픈소스 플랫폼

사람이 하면 복잡한 작업을 자동으로 해준다.

**소개**

- 운영에서 사용가능한 컨테이너 오케스트레이션
- 스케일 상관x
- 다양한 요구사항 만족
- AWS, Google 등 어디서든 동작 가능

사실상의 표준 : 대부분의 회사에서 사용

확장성이 좋다.

도커는 각 앱마다 필요한 환경을 컨테이너로 관리하는 프로그램이고 쿠버네티스는 각 컨테이너의 배포를 중앙관리하는 프로그램

<br>

# 배포 프로세스 개선

### 배포 프로세스 고민

배포를 더 자주 할 수 있을까? → 더 작은 단위로 자주 배포

배포를 더 빠르게 할 수 있을까? → 소스를 푸시하면 자동으로 빌드

배포를 더 많이 할 수 있을까? → 테스트 서버 수를 늘리기

배포를 더 자유롭게 할 수 있을까? → 배포권한을 확대

⇒ 개발하는데 집중할 수 있게 해줌

### 2차 개선

모든 브랜치는 자동으로 빌드되어 도커 이미지로 만들어짐

- 바로 배포 가능한 도커 이미지가 항시 대기중

테스트, QA를 하기 위해서 여러개의 서버 중 원하는 서버를 사용하고 완료되면 종료

- 누가 몇번 서버에서 어떤 브랜치를 테스트 중인지 Jenkins에서 확인

진행중인 테스트를 기다리지 않고 여러개의 테스트를 동시에 진행하고 배포

- 테스트 서버를 늘려놓음

### 새로운 문제점

테스트 서버를 관리해야 하는 불편함(ex. 1번 서버 로그인 테스트, 2번 서버 결제 테스트 등)

사용하지 않는 테스트 서버의 자원 낭비

테스트가 몰릴 경우 여전히 기다려야 하는 문제(테스트 서버 부족)

배포 화면 입력 실수가 있을  수 있음

테스트 완료한 서버 회수가 늦어짐

Jenkins도 좋지만 획기적인 개선이 어려움

- **GitOps 활용**

<br>

# DevOps 엔지니어

### DevOps 역할

- 서비스를 배포하고 지원 + 모니터링

- 배포 파이프라인 구성

- 더 자주 더 빠른 릴리스

  ✅ 릴리스 : 소스가 고객한테 얼마나 빨리 배포되는지

- Cloud(AWS, Google Cloud, Azure, ...) / Cloud Native

- 컨테이너(Docker, Kuvernetes, ...)

- 보안 Network, IAM, Service Mesh, ...

- 장애 대응

- IaC(설정으로 만들어서 관리) - 테라폼, ...

- SRE - SLI, SLO, ...

- 외부 서비스 - DataDog, NewRelic, ...

### DevOps 로드맵

https://roadmap.sh/devops